Day 1 – Basic Linux Commands
ls – Lists files and directories in the current location.

pwd – Prints the current working directory path.

touch <filename> – Creates an empty file.

cat <filename> – Displays the content of a file.

cd <path> – Changes the current directory.

mkdir <folder> – Creates a new folder.

rm <file> – Deletes a file.

man <command> – Opens the manual page for a command.

clear – Clears the terminal screen.

su <username> - to change  to another user

whatis <command related keyword> -this gives u simple understanding of the command usage in one line

vim <filename> – Opens a file in the Vim editor.

whoami – Shows the currently logged-in user.
.................................................................................................................................................................................................

Day 2 – Users, Groups, and Permissions
sudo adduser <username> – Creates a new user.

chmod 777 <filename> – Sets full read, write, and execute permissions for all

chown <newowner> <filename> – Changes the file ownership to another user.

 if u want to change both the file and group this is the command --> chown username:groupname filename

Vim Shortcuts:
i – Enters insert mode to edit text.

:wq – Saves and exits Vim.

:q! – Exits Vim without saving.

./file.sh – Executes a shell script.
.................................................................................................................................................................................................

Day 3 – File Paths and Utilities
cd /path – Navigates using absolute path from root.

cd folder – Navigates using relative path from current directory.

ls -lt – Lists files sorted by modification time (latest first).

file <filename> – Shows the type of content inside a file.

less <filename> – Views file content with scroll/search. Use q to exit.

/search in less – Searches for a keyword inside a file.

history – Shows command history. Use Ctrl + R to search previous commands.

cp file dir/ – Copies a file into a directory.

cp -r dir1 dir2/ – Recursively copies one directory into another.

cp -i file dir/ – Prompts before overwriting during copy.

mv old new – Renames or moves a file.

mv -b file dir/ – Moves file and keeps a backup if overwritten (~ suffix).

head -n 10 file – Shows first 10 lines of a file.   // if u need 1st 10 lines of log file u can do -- head -n 10 /var/log/syslog

tail -n 10 file – Shows last 10 lines of a file.

tail -f file – Continuously displays new lines added to a file (live view).

find <dir> -name <filename> – Searches for files by name.

find <dir> -type d -name <folder> – Searches for directories by name.

find <dir> -type f -name <file> – Searches for regular files by name.
.................................................................................................................................................................................................

Day 4 – I/O Redirection, Pipes, and File Utilities
echo "text" > file – Replaces file content with "text".

echo "text" >> file – Appends "text" at the end of the file.

ls | grep pattern – Filters list output for matching pattern.

ls | tee file.txt – Saves output to a file while displaying it.

cut command:
cut -c 5 file – Shows the 5th character of each line.

cut -f 2 file – Extracts the 2nd field (tab-delimited) from each line.

cut -f 1 -d " " file – Extracts 1st field separated by space.

cut -f 5 -d "," file – Extracts 5th field separated by commas.

cut -c 5-10 file – Shows characters from 5 to 10.

cut -c 5- file – Shows characters from position 5 onwards.

cut -c -5 file – Shows first 5 characters.

cat -A file – Makes tabs and special characters visible.

Tabs & Expansion:
expand file > new.txt – Converts tabs to spaces.

unexpand -a new.txt > result.txt – Converts spaces back to tabs.  // here -a stands for convert spaces to tabs in the whole file but if u not mention it searches at only at starting of each line in the file for possible converstion of spaces tabs.

Splitting Files:
split -l 5 file part_ – Splits file into chunks of 5 lines each.

split -b 200 file part_ – Splits file into chunks of 200 bytes.

Join Files
join file1 file2 – Joins files based on the first column.

join -1 2 -2 1 file1 file2 – Joins using column 2 of file1 and column 1 of file2.

Sorting Files
sort file – Sorts file content in in alphabetical order.

sort -r file – Sorts content in reverse of default sorting order.

sort -n file – this is actually used when the content is numeric it sorts in ascending order.

sort -rn file – this is also for numeric content ,as -r is used it reverses the default sorting(ascending order) and Sorts numbers in descending order.

sort -n -k3 file -- this sorts based on column here for example  i mentioned  3  so it sorts based on 3rd column and based on column data type here i choose -n as my third column is numerical.


-----------------------------------------------------------------------------------------------------------------------
day -8
The first line of the shell script file begins with a "sha-bang" (#!) which is not read as a comment, followed by the full path where the shell interpreter is located. 

This path, tells the operating system that this file is a set of commands to be fed into the interpreter indicated.

which command gives the path of the thing u need like 

which <installed software> like  ex: which python , which git 

—> use of this command is to check the path of its installment , and is it there or not .

Encapsulating the variable name with "" will preserve any white space values




greeting='Hello        world!'
echo $greeting" now with spaces: $greeting"



Encapsulating the variable name with ${} is used to avoid ambiguity , here to get a clear vision of the variable we use ${variable name}    THIS IS OPTIONAL

MyFirstLetters=ABC
echo "The first 10 letters in the alphabet are: ${MyFirstLetters}DEFGHIJ"

if [ m -eq 1]  ——— > -eq used for numerical

if [m == “sai”] ————> used for strings = or ==

------------------------------------------------------------------------------------------------------------------------

day 10



Day 10 – CronTab Basics (Linux Task Scheduler)
==============================================

What is CronTab?
----------------
CronTab automates repetitive tasks on Linux (e.g., backups, monitoring, reports).

Basic Syntax:
-------------
* * * * * /path/to/script.sh
│ │ │ │ │
│ │ │ │ └── Day of week (0–7, Sun=0/7)
│ │ │ └──── Month (1–12)
│ │ └────── Day of month (1–31)
│ └──────── Hour (0–23)
└────────── Minute (0–59)

Common Commands:
----------------
- crontab -l → List jobs
- crontab -e → Edit/add job

Examples:
---------
- Run every day at 9:30 PM:
  30 21 * * * /home/user/script.sh

- Run once at boot:
  @reboot /home/user/startup.sh

Shortcuts:
----------
@reboot  - At system startup
@daily   - Every day @ midnight
@weekly  - Every Sunday @ 12AM
@monthly - 1st of month @ 12AM
@yearly  - Jan 1st @ 12AM

Use Cases:
----------
- Start server at boot (@reboot)
- Disk usage check daily
- Auto-backup every week
- Log cleaner every hour

------------------------------------------------------------------------------------------------------------------

DAY 11 ,DAY 12

# 📘 Networking Basics for DevOps

This documentation covers foundational networking concepts, explained with real-world examples, IP calculations, and commands.

---

## 🔹 1. **IP Address**

**What is it?**
An IP address is a unique identifier assigned to every device connected to a network. It ensures that data sent over a network reaches the correct destination.

### 🔸 Use Case:

Imagine your laptop is connected to a Wi-Fi network. It gets assigned an IP address like `192.168.1.100` by the router. This allows the router to recognize and communicate with your laptop, and also differentiate it from other connected devices.

### 🔸 Command:

```bash
ip a           # Shows IP addresses of all interfaces
```

---

## 🔹 2. **Subnetting**

**What is it?**
Subnetting divides a large IP network into smaller, manageable subnetworks. This improves routing efficiency and enhances security.

### 🔸 Use Case:

Suppose your office has 300 devices. You receive an IP block `192.168.0.0/24`, which gives 256 IPs (254 usable). You can create subnets for different departments like:

* HR: `192.168.0.0/26` → 64 IPs (62 usable)
* IT: `192.168.0.64/26` → 64 IPs (62 usable)
* Admin: `192.168.0.128/26` → 64 IPs (62 usable)
* Guest: `192.168.0.192/26` → 64 IPs (62 usable)

This allows better traffic control and isolation.

### 🔸 Command:

```bash
ipcalc 192.168.0.0/25    # If ipcalc is installed
```

---

## 🔹 3. **Ports**

**What is it?**
Ports are logical endpoints for communication. While an IP address identifies a device, ports identify specific processes/services on that device.

### 🔸 Use Case:

Let’s say your server has IP `192.168.1.10`. It hosts a website and an SSH server:

* Website uses port `80`
* SSH uses port `22`

So a user typing `http://192.168.1.10` sends a request to port `80`, while SSH clients connect to port `22`. Without ports, your system wouldn't know which application should handle incoming traffic.

### 🔸 Command:

```bash
sudo ss -tuln      # Show open ports and services
```

---

## 🔹 4. **DNS (Domain Name System)**

**What is it?**
DNS translates domain names (like `google.com`) into IP addresses that machines understand.

### 🔸 Use Case:

When you type `openai.com` into a browser, your system contacts a DNS server to resolve it into an IP like `104.22.61.161`. Without DNS, you'd need to memorize and type IP addresses instead of names.

### 🔸 Command:

```bash
dig google.com +short      # Show IP of domain
host google.com            # Another way
```

---

## 🔹 5. **NAT (Network Address Translation)**

**What is it?**
NAT allows multiple devices on a private network to access the internet using a single public IP address.

### 🔸 Use Case:

At home, your devices have private IPs (like `192.168.0.x`). When you open YouTube, your router (which has a public IP) sends the request on your behalf and maps the incoming response back to your device. NAT hides internal IPs from the external world.

### 🔸 Command:

```bash
ip a             # Check private IP
curl ifconfig.me # Check public IP (via NAT)
```

---

## 🔹 6. **Routing**

**What is it?**
Routing decides how data travels across networks, hopping from one router to another until it reaches its destination.

### 🔸 Use Case:

You run `ping google.com` from your terminal. Your data doesn't go directly to Google but passes through various routers. Each router reads its routing table to decide the next hop.

### 🔸 Command:

```bash
ip route                    # Show routing table
traceroute google.com       # Show route taken to Google
```

---

## 🔹 7. **Default Gateway**

**What is it?**
The default gateway is the device (usually a router) that your system sends all traffic to when it doesn't know the destination.

### 🔸 Use Case:

Your device is on network `192.168.1.0/24`. If you try to access `8.8.8.8` (Google DNS), your system sends it to the default gateway (e.g., `192.168.1.1`), which forwards it outside your local network.

### 🔸 Command:

```bash
ip route | grep default
```

---

## 🔹 8. **Firewall**

**What is it?**
A firewall monitors and filters incoming/outgoing traffic based on predefined rules.

### 🔸 Use Case:

You deploy a local web server on port `3000`. To let others access it, you must open this port in your firewall. Otherwise, even if the server is running, external users can't connect.

### 🔸 Commands:

```bash
sudo ufw enable                # Enable firewall
sudo ufw allow 3000           # Allow traffic to port 3000
sudo ufw deny 3000            # Deny traffic to port 3000
sudo ufw status verbose       # Show rules
```

---

## ✅ Summary of Commands

```bash
ip a                     # Show IPs
ipcalc 192.168.0.0/25    # Subnet calculation
sudo ss -tuln            # Open ports
dig google.com +short    # DNS resolve
curl ifconfig.me         # Show public IP (NAT)
ip route                 # Routing table
traceroute google.com    # Network path
sudo ufw allow 3000      # Open firewall port
```

